<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>MBMLDataProcessingFunctions Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.2 (build 963)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">Mockingbird Data Environment </a></h1>
				<a id="developerHome" href="../index.html">Gilt Groupe</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">MBMLDataProcessingFunctions Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/appendArrays:">&nbsp;&nbsp;&nbsp;&nbsp;+ appendArrays:</option>
	
	<option value="//api/name/associate:">&nbsp;&nbsp;&nbsp;&nbsp;+ associate:</option>
	
	<option value="//api/name/associateWithArray:">&nbsp;&nbsp;&nbsp;&nbsp;+ associateWithArray:</option>
	
	<option value="//api/name/associateWithSingleValue:">&nbsp;&nbsp;&nbsp;&nbsp;+ associateWithSingleValue:</option>
	
	<option value="//api/name/collectionPassesTest:">&nbsp;&nbsp;&nbsp;&nbsp;+ collectionPassesTest:</option>
	
	<option value="//api/name/containsValue:">&nbsp;&nbsp;&nbsp;&nbsp;+ containsValue:</option>
	
	<option value="//api/name/distributeArrayElements:">&nbsp;&nbsp;&nbsp;&nbsp;+ distributeArrayElements:</option>
	
	<option value="//api/name/filter:">&nbsp;&nbsp;&nbsp;&nbsp;+ filter:</option>
	
	<option value="//api/name/flattenArrays:">&nbsp;&nbsp;&nbsp;&nbsp;+ flattenArrays:</option>
	
	<option value="//api/name/groupArrayElements:">&nbsp;&nbsp;&nbsp;&nbsp;+ groupArrayElements:</option>
	
	<option value="//api/name/join:">&nbsp;&nbsp;&nbsp;&nbsp;+ join:</option>
	
	<option value="//api/name/list:">&nbsp;&nbsp;&nbsp;&nbsp;+ list:</option>
	
	<option value="//api/name/mergeDictionaries:">&nbsp;&nbsp;&nbsp;&nbsp;+ mergeDictionaries:</option>
	
	<option value="//api/name/pruneMatchingLeaves:">&nbsp;&nbsp;&nbsp;&nbsp;+ pruneMatchingLeaves:</option>
	
	<option value="//api/name/pruneNonmatchingLeaves:">&nbsp;&nbsp;&nbsp;&nbsp;+ pruneNonmatchingLeaves:</option>
	
	<option value="//api/name/reduce:">&nbsp;&nbsp;&nbsp;&nbsp;+ reduce:</option>
	
	<option value="//api/name/setContains:">&nbsp;&nbsp;&nbsp;&nbsp;+ setContains:</option>
	
	<option value="//api/name/sort:">&nbsp;&nbsp;&nbsp;&nbsp;+ sort:</option>
	
	<option value="//api/name/split:">&nbsp;&nbsp;&nbsp;&nbsp;+ split:</option>
	
	<option value="//api/name/splitLines:">&nbsp;&nbsp;&nbsp;&nbsp;+ splitLines:</option>
	
	<option value="//api/name/unique:">&nbsp;&nbsp;&nbsp;&nbsp;+ unique:</option>
	
	<option value="//api/name/valuesIntersect:">&nbsp;&nbsp;&nbsp;&nbsp;+ valuesIntersect:</option>
	
	<option value="//api/name/valuesPassingTest:">&nbsp;&nbsp;&nbsp;&nbsp;+ valuesPassingTest:</option>
	
	
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Testing containers">Testing containers</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Joining &amp; splitting strings">Joining &amp; splitting strings</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Manipulating arrays">Manipulating arrays</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Manipulating dictionaries">Manipulating dictionaries</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Pruning trees">Pruning trees</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Extracting data">Extracting data</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Sorting">Sorting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Removing duplicate values">Removing duplicate values</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Reducing an array of items">Reducing an array of items</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Distributing values">Distributing values</a></span></li>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/appendArrays:">appendArrays:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/associate:">associate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/associateWithArray:">associateWithArray:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/associateWithSingleValue:">associateWithSingleValue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/collectionPassesTest:">collectionPassesTest:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/containsValue:">containsValue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/distributeArrayElements:">distributeArrayElements:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/filter:">filter:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/flattenArrays:">flattenArrays:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/groupArrayElements:">groupArrayElements:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/join:">join:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/list:">list:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/mergeDictionaries:">mergeDictionaries:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/pruneMatchingLeaves:">pruneMatchingLeaves:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/pruneNonmatchingLeaves:">pruneNonmatchingLeaves:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/reduce:">reduce:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setContains:">setContains:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sort:">sort:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/split:">split:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/splitLines:">splitLines:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/unique:">unique:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/valuesIntersect:">valuesIntersect:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/valuesPassingTest:">valuesPassingTest:</a></span></li>
	
</ul></li>




			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="MBMLDataProcessingFunctions Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">MBMLDataProcessingFunctions Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">MBMLDataProcessingFunctions.h</td>
</tr>
						</tbody></table></div>
					
                    
                    
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>This class provides a set of MBML functions for manipulating data structures.</p>

<h3>Terminology</h3>

<p><strong>Container objects:</strong> Where parameters are referred to as <em>container
objects</em>, the function will accept <code>NSDictionary</code>, <code>NSArray</code> or <code>NSSet</code>
instances.</p>

<h3>About function declarations</h3>

<p>These functions are exposed to the Mockingbird environment via
<code>&lt;Function ... /&gt;</code> declarations in the <code><a href="../Classes/MBDataEnvironmentModule.html">MBDataEnvironmentModule</a>.xml</code>
file.</p>

<p>For more information on MBML functions, see the <a href="../Classes/MBMLFunction.html"><code>MBMLFunction</code></a> class.</p>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						<a title="Testing containers" name="task_Testing containers"></a>
						<h3 class="subsubtitle task-title">Testing containers</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/containsValue:">+&nbsp;containsValue:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setContains:">+&nbsp;setContains:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/collectionPassesTest:">+&nbsp;collectionPassesTest:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/valuesPassingTest:">+&nbsp;valuesPassingTest:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/valuesIntersect:">+&nbsp;valuesIntersect:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Joining &amp; splitting strings" name="task_Joining &amp; splitting strings"></a>
						<h3 class="subsubtitle task-title">Joining &amp; splitting strings</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/join:">+&nbsp;join:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/split:">+&nbsp;split:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/splitLines:">+&nbsp;splitLines:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Manipulating arrays" name="task_Manipulating arrays"></a>
						<h3 class="subsubtitle task-title">Manipulating arrays</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/appendArrays:">+&nbsp;appendArrays:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/flattenArrays:">+&nbsp;flattenArrays:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Manipulating dictionaries" name="task_Manipulating dictionaries"></a>
						<h3 class="subsubtitle task-title">Manipulating dictionaries</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/mergeDictionaries:">+&nbsp;mergeDictionaries:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Pruning trees" name="task_Pruning trees"></a>
						<h3 class="subsubtitle task-title">Pruning trees</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/pruneMatchingLeaves:">+&nbsp;pruneMatchingLeaves:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/pruneNonmatchingLeaves:">+&nbsp;pruneNonmatchingLeaves:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Extracting data" name="task_Extracting data"></a>
						<h3 class="subsubtitle task-title">Extracting data</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/filter:">+&nbsp;filter:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/list:">+&nbsp;list:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/associate:">+&nbsp;associate:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/associateWithSingleValue:">+&nbsp;associateWithSingleValue:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/associateWithArray:">+&nbsp;associateWithArray:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Sorting" name="task_Sorting"></a>
						<h3 class="subsubtitle task-title">Sorting</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/sort:">+&nbsp;sort:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Removing duplicate values" name="task_Removing duplicate values"></a>
						<h3 class="subsubtitle task-title">Removing duplicate values</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/unique:">+&nbsp;unique:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Reducing an array of items" name="task_Reducing an array of items"></a>
						<h3 class="subsubtitle task-title">Reducing an array of items</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/reduce:">+&nbsp;reduce:</a></code>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Distributing values" name="task_Distributing values"></a>
						<h3 class="subsubtitle task-title">Distributing values</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/distributeArrayElements:">+&nbsp;distributeArrayElements:</a></code>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/groupArrayElements:">+&nbsp;groupArrayElements:</a></code>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/appendArrays:" title="appendArrays:"></a>
	<h3 class="subsubtitle method-title">appendArrays:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns a single array containing all the elements in the arrays specified
in the input parameters.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)appendArrays:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An array containing all of the elements in the arrays referenced
            by the passed-in expression parameters.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two or more pipe-separated object expressions
as parameters, where each expression yields an <code>NSArray</code> instance.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$array1</code>, <code>$array2</code> and <code>$array3</code> resolve to array values:</p>

<pre><code>^appendArrays($array1|$array2|$array3)
</code></pre>

<p>The expression above will evaluate to a single array, wherein the returned
array will contain all the elements of <code>$array1</code>, in the same order they
appear in the array, followed by the elements of <code>$array2</code>, and then those
of <code>$array3</code>.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/associate:" title="associate:"></a>
	<h3 class="subsubtitle method-title">associate:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a container object holding an arbitrary data model.
The keys and values of the returned dictionary are constructed based
on expressions passed to the function.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)associate:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p><strong>Note:</strong> If the association would result in more than one value for a given
key, the multiple values will be placed into an array, and that array will be
the value of the key.</p>

<p>This Mockingbird function accepts three or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an expression whose value is a container object
(either an array or dictionary) that will be used as the source for the
returned dictionary</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which is used to construct the keys in the map</p></li>
<li><p>The last expression is the <em>value expression</em>, which is used to
construct the values contained in the map</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code></p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model</p></li>
<li><p>When the data model expression refers to a dictionary, <code>$rootKey</code>
will contain the key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as
<code>$``outer:key</code> or <code>$outer:item</code>. This prefix
can also be compounded (eg.: <code>$outer:outer:key</code>) to reach different
levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associate($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>In the event that more than one child has a given full name, the corresponding
value in the dictionary will be an array.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection see-also-section">
		<h4 class="method-subtitle">See Also</h4>
		<ul>
			
			<li><code><p><a href="#//api/name/associateWithArray:">+ associateWithArray:</a>, <a href="#//api/name/associateWithSingleValue:">+ associateWithSingleValue:</a></p></code></li>
			
		</ul>
	</div>
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/associateWithArray:" title="associateWithArray:"></a>
	<h3 class="subsubtitle method-title">associateWithArray:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a container object holding an arbitrary data model.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)associateWithArray:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The keys and values of the returned dictionary are constructed based
on expressions passed to the function.</p>

<p><strong>Note:</strong> The value of each key will always be an array, even if the key
only maps to a single value.</p>

<p>This Mockingbird function accepts three or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an expression whose value is a container object
(either an array or dictionary) that will be used as the source for the
returned dictionary</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which is used to construct the keys in the map</p></li>
<li><p>The last expression is the <em>value expression</em>, which is used to
construct the values contained in the map</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code></p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model</p></li>
<li><p>When the data model expression refers to a dictionary, <code>$rootKey</code>
will contain the key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as <code>$outer:key</code> or
<code>$outer:item</code>. This prefix can also be compounded (eg.: <code>$outer:outer:key</code>)
to reach different levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associateWithArray($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>Regardless of whether or not a given key has multiple values, each key
in the returned dictionary will have an array value.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection see-also-section">
		<h4 class="method-subtitle">See Also</h4>
		<ul>
			
			<li><code><p><a href="#//api/name/associate:">+ associate:</a>, <a href="#//api/name/associateWithSingleValue:">+ associateWithSingleValue:</a></p></code></li>
			
		</ul>
	</div>
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/associateWithSingleValue:" title="associateWithSingleValue:"></a>
	<h3 class="subsubtitle method-title">associateWithSingleValue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Associates a set of keys with values by iterating over (and potentially
recursing into) a container object holding an arbitrary data model.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)associateWithSingleValue:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The keys and values of the returned dictionary are constructed based
on expressions passed to the function.</p>

<p><strong>Note:</strong> If the association would result in more than one value for a given
key, additional values are ignored and only one value will be returned. Assume
non-deterministic behavior for multiple values.</p>

<p>This Mockingbird function accepts three or more pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>data model</em>, an expression whose value is a container object
(either an array or dictionary) that will be used as the source for the
returned dictionary</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model</p></li>
<li><p>The second-to-last expression in the input parameters is the <em>key
expression</em>, which is used to construct the keys in the map</p></li>
<li><p>The last expression is the <em>value expression</em>, which is used to
construct the values contained in the map</p></li>
</ul>


<p>The intermediate, key and value expressions can refer to portions of the
data model using several pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value of the current item in the innermost
scope being iterated/recursed</p></li>
<li><p>When iterating the values of a dictionary, the <code>$key</code> variable
can be used to access the key associated with the current <code>$item</code></p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model</p></li>
<li><p>When the data model expression refers to a dictionary, <code>$rootKey</code>
will contain the key associated with the current <code>$root</code> value.</p></li>
<li><p>In addition, when intermediate expressions are used to recurse into the
data model, you can refer to items and keys contained in the outer scopes
using the prefix <code>outer:</code> in the variable name, such as <code>$outer:key</code> or
<code>$outer:item</code>. This prefix can also be compounded (eg.: <code>$outer:outer:key</code>)
to reach different levels of scope.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^associateWithSingleValue($people|$item.children|$item.fullName|$root)
</code></pre>

<p>The expression above would iterate over all the values in <code>$people</code>, and for
each person, it would then iterate over the elements contained in the person&rsquo;s
<code>children</code> array. For each of those children, it would create an association
between the <em>key</em>—the value of that child&rsquo;s <code>fullName</code> attribute—and the
<em>value</em>—the <code>$root</code> item (the current person in the iteration from <code>$people</code>).</p>

<p>In other words, the expression above would create a dictionary where the keys
are the full names of children, and the value of each key is the item in
<code>$people</code> representing that child&rsquo;s parent.</p>

<p>Because this function associates a given key with at most one value, in the
event that more than one child has a given full name, some values will be
ignored.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection see-also-section">
		<h4 class="method-subtitle">See Also</h4>
		<ul>
			
			<li><code><p><a href="#//api/name/associateWithArray:">+ associateWithArray:</a>, <a href="#//api/name/associate:">+ associate:</a></p></code></li>
			
		</ul>
	</div>
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/collectionPassesTest:" title="collectionPassesTest:"></a>
	<h3 class="subsubtitle method-title">collectionPassesTest:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Applies a boolean expression test to each member of the passed collection
and returns whether or not all members passed the test.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)collectionPassesTest:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An <code>NSNumber</code> instance containing either the boolean
            value <code>YES</code> if all of the input collections pass the
            specified Mockingbird expression, or <code>NO</code> otherwise.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p><strong>Note:</strong> This method tests equality through the <a href="../Classes/MBExpression.html">MBExpression</a> class, not the
<code>isEqual:</code> method. As a result, implicit type conversions occur, allowing
an <code>NSNumber</code> instance containing the integer <code>5</code> to equal an <code>NSString</code>
containing the text &ldquo;<code>5</code>&rdquo;. Be forewarned, however: Do not expect normal
<code>NSObject</code> equality test behavior!</p>

<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>One <em>container object</em></p></li>
<li><p>The <em>test value</em>, an expression whose value will be used to test
against the values in the passed-in container(s)</p></li>
</ul>


<h4>Expression usage</h4>

<pre><code>^collectionPassesTest($collection|$item.length -GT 0)
</code></pre>

<p>The expression above would return a boolean true value if all
the members of <code>$collection</code> pass the Mockingbird expression
<code>$item.length -GT 0</code></p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/containsValue:" title="containsValue:"></a>
	<h3 class="subsubtitle method-title">containsValue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Determines whether any of the values contained within one or more container
objects equals a specified value.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)containsValue:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An <code>NSNumber</code> instance containing either the boolean
            value <code>YES</code> if any of the input parameters contains the specified
            element, or <code>NO</code> otherwise.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p><strong>Note:</strong> This method tests equality through the <a href="../Classes/MBExpression.html">MBExpression</a> class, not the
<code>isEqual:</code> method. As a result, implicit type conversions occur, allowing
an <code>NSNumber</code> instance containing the integer <code>5</code> to equal an <code>NSString</code>
containing the text &ldquo;<code>5</code>&rdquo;. Be forewarned, however: Do not expect normal
<code>NSObject</code> equality test behavior!</p>

<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>One or more <em>container objects</em>, expressions that evaluate to array
or dictionary values</p></li>
<li><p>The <em>test value</em>, an expression whose value will be used to test
equality with the values in the passed-in container(s)</p></li>
</ul>


<h4>Expression usage</h4>

<pre><code>^containsValue($colorsOne|$colorsTwo|yellow)
</code></pre>

<p>The expression above would return a boolean true value if either <code>$colorsOne</code>
or <code>$colorsTwo</code> contained an item whose value is the string &ldquo;<code>yellow</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/distributeArrayElements:" title="distributeArrayElements:"></a>
	<h3 class="subsubtitle method-title">distributeArrayElements:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Distributes the elements in a single array across multiple arrays.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)distributeArrayElements:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An array containing <em>returned array count</em> arrays, each
            containing the distributed elements from <em>source array</em>.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an expression that is expected to evaluate
as an array value.</p></li>
<li><p>The <em>returned array count</em>, which specifies the number of arrays
across which to distribute the source array&rsquo;s elements. This expression
will be interpreted as integer value, and must be <code>1</code> or
greater.</p></li>
</ul>


<p>The source array is iterated, and each item in it is distributed across
<em>returned array count</em> arrays in sequence.</p>

<p>The function will always return the number of arrays specified by
<em>returned array count</em>. If the source array contains fewer elements
than <em>returned array count</em>, one or more of the returned arrays
will be empty.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$newYorkTeams</code> is an array with five elements: the strings
&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Mets</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo;, <code>Rangers</code> and &ldquo;<code>Nets</code>&rdquo; in that
order.</p>

<pre><code>^distributeArrayElements($newYorkTeams|2)
</code></pre>

<p>The expression above would return an array containing two arrays, where the
first array contains three items (&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo; and &ldquo;<code>Nets</code>&rdquo;) and
the second array contains two (&ldquo;<code>Mets</code>&rdquo; and &ldquo;<code>Rangers</code>&rdquo;).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/filter:" title="filter:"></a>
	<h3 class="subsubtitle method-title">filter:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Filters a collection object by applying a test expression to the contents
of each object in the collection. Each top-level object in the collection
where the test expression evaluates to true according to the rules of
the filter behavior is returned.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)filter:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An array or dictionary containing the filtered items. The type of
            the object returned will match the <em>data model</em> input
            parameter.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Because you can recurse into portions of the data model where more than
one element may exist, the filter may iterate over multiple items for each
top-level object, and the test expression will get applied multiple times.
You can specify whether the filter will return items that match at least
once, or whether all of the existing items must match.</p>

<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an expression whose value is a container object
(either an array or dictionary) that will be used as the source for the
filtering</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model</p></li>
<li><p>A <em>test expression</em>, which will be used for the basis of the
filtering.</p></li>
<li><p>Finally, an optional <em>filter behavior</em>, which can be either
<code>matchAtLeastOnce</code> or <code>matchAll</code> (note that these string
literals must be used; this parameter is not evaluated). If the parameter is
omitted <code>matchAtLeastOnce</code> behavior will be used.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$people</code> is an array of data objects representing people:</p>

<pre><code>^filter($people|$item.children|$item.aunt|$item.firstName -EQ Jill|matchAll)
</code></pre>

<p>The expression above would return all the objects contained in
<code>$people</code> where every aunt of every child of the person has
the first name Jill. The <code>matchAll</code> parameter can be omitted
to return every person with at least one child who has at least one aunt
with the first name Jill.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/flattenArrays:" title="flattenArrays:"></a>
	<h3 class="subsubtitle method-title">flattenArrays:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns a single array containing all the elements of the array(s) specified
in the parameters, wherein any element that is an array will be flattened
such that the returned array contains no nested arrays. This does a
depth-first traversal of the input parameters.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)flattenArrays:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The flattened array.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts one or more pipe-separated object expressions
as parameters, where each expression yields an <code>NSArray</code> instance.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$nestedArrays</code> refers to an array wherein each element is
another array:</p>

<pre><code>^flattenArrays($nestedArrays)
</code></pre>

<p>The example above would return an array containing the elements of each array
contained in <code>$nestedArrays</code>.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/groupArrayElements:" title="groupArrayElements:"></a>
	<h3 class="subsubtitle method-title">groupArrayElements:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Groups the elements in a single array into multiple arrays.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)groupArrayElements:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>an array containing one or more <em>group arrays</em>.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an expression that is expected to evaluate
as an array value.</p></li>
<li><p>A <em>group size</em>, which specifies the maximum number of items to allow
in a single group. This expression will be interpreted as integer value, and
must be <code>1</code> or greater.</p></li>
</ul>


<p>The source array is iterated, and for each <em>group size</em> number of
items encountered, a new <em>group array</em> is created containing just those
items. The return value is an array containing one or more group arrays
created while iterating the source array.</p>

<p>Unless <em>source array</em> contains an exact multiple of <em>group size</em> number of
items, the last group array will contain fewer than <em>group size</em> number of
items.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$newYorkTeams</code> is an array with five elements: the strings
&ldquo;<code>Yankees</code>&rdquo;, &ldquo;<code>Mets</code>&rdquo;, &ldquo;<code>Knicks</code>&rdquo;, <code>Rangers</code> and &ldquo;<code>Nets</code>&rdquo; in that
order.</p>

<pre><code>^groupArrayElements($newYorkTeams|2)
</code></pre>

<p>The expression above would return an array containing three arrays, where the
first array contains two items (&ldquo;<code>Yankees</code>&rdquo; and &ldquo;<code>Mets</code>&rdquo;), the second array
contains two items (&ldquo;<code>Knicks</code>&rdquo; and &ldquo;<code>Rangers</code>&rdquo;), and the third array contains
one item (&ldquo;<code>Nets</code>&rdquo;).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/join:" title="join:"></a>
	<h3 class="subsubtitle method-title">join:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Creates a string by concatenating the string values of the elements
in one or more container objects, using the specified separator
string between each value in the returned string.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)join:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>A string containing the string values of the items in the
            <em>container objects</em>, separated by the string specified
            as the <em>separator string</em></p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>One or more <em>container objects</em>, expressions that evaluate to arrays
or dictionaries</p></li>
<li><p>The <em>separator string</em>, which is placed between each value in the
returned string</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$values</code> is an array containing the strings &ldquo;<code>string1</code>&rdquo;,
&ldquo;<code>anotherString</code>&rdquo;, and &ldquo;<code>lastly</code>&rdquo;:</p>

<pre><code>^join($values|, )
</code></pre>

<p>The expression above would yield the string &ldquo;<code>string1, anotherString, lastly</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/list:" title="list:"></a>
	<h3 class="subsubtitle method-title">list:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Iterates over (and potentially recurses into) the items in a container object,
and returns a list of values. The values in the returned list will reflect the
ordering of any arrays iterated, however iterating dictionaries will result in
non-deterministic ordering.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)list:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two or more pipe-separated expressions as
parameters:</p>

<ul>
<li><p>The <em>data model</em>, an expression whose value is a container object
(either an array or dictionary) that will be iterated</p></li>
<li><p>Zero or more <em>intermediate expressions</em>, which are used to recurse
into portions of the data model</p></li>
<li><p>A <em>value expression</em>, which will be evaluated once for each item
encountered while iterating the data model and recursing into any
intermediate expressions.</p></li>
</ul>


<p>The function will return an array containing the result of evaluating the
<em>value expression</em> once for each item encountered in the data
model.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$states</code> is a map where each item in the map represents a state.
The key for each item is the two-letter postal code for the state, and the
value associated with each key is another dictionary containing additional
information about the state.</p>

<pre><code>^list($states|$item.citiesBySize|$item.name, &lt;span&gt;$&lt;/span&gt;root:key - $item.population residents)
</code></pre>

<p>The expression above would iterate over all the elements in the
<code>$states</code> dictionary, and for each state, it would then iterate over
the elements contained in the states&rsquo;s <code>cityBySize</code> property, which
in this case is an ordered array of cities in the state sorted by population.
For each city in each state&rsquo;s <code>cityBySize</code>, the returned array would
contain a string with values such as:</p>

<pre><code>New York, NY - 8,391,881 residents
</code></pre>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/mergeDictionaries:" title="mergeDictionaries:"></a>
	<h3 class="subsubtitle method-title">mergeDictionaries:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Merges a set of dictionaries into a single dictionary.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)mergeDictionaries:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts at least two pipe-separated object
expressions as input parameters:</p>

<ul>
<li><p>The <em>first input dictionary</em>, an <code>NSDictionary</code> instance</p></li>
<li><p>The <em>second input dictionary</em>, an <code>NSDictionary</code> instance</p></li>
<li><p>Zero or more <em>additional input dictionaries</em>, each an <code>NSDictionary</code> instance</p></li>
</ul>


<p>The return value will be the result of overlaying the values of each input
dictionary parameter with the dictionary parameter that preceded it. The
resulting dictionary will contain keys from all input dictionaries, and if
there are any duplicate keys, the value from the right-most parameter
will be selected.</p>

<p>For example, if <em>second input dictionary</em> contains a value for a key that&rsquo;s
also present in <em>first input dictionary</em>, the key/value pair from <em>second input
dictionary</em> will overwrite the first.</p>

<h4>Expression usage</h4>

<pre><code>^mergeDictionaries($localUsers|$remoteUsers|$automatedUsers)
</code></pre>

<p>The dictionaries yielded by the expressions <code>$localUsers</code>, <code>$remoteUsers</code> and
<code>$automatedUsers</code> are merged such that:</p>

<ul>
<li><p>Each key/value pair in <code>$automatedUsers</code> will be present in the returned
 dictionary</p></li>
<li><p>For each key in <code>$remoteUsers</code> not present in <code>$automatedUsers</code>, the
 key/value in <code>$remoteUsers</code> will be present in the returned dictionary</p></li>
<li><p>For each key in <code>$remoteUsers</code> not present in <code>$automatedUsers</code>, the
 key/value in <code>$remoteUsers</code> will be present in the returned dictionary</p></li>
<li><p>For each key in <code>$localUsers</code> not present in <code>$remoteUsers</code> or
 <code>$automatedUsers</code>, the key/value in <code>$localUsers</code> will be present in the
 returned dictionary</p></li>
</ul>

	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/pruneMatchingLeaves:" title="pruneMatchingLeaves:"></a>
	<h3 class="subsubtitle method-title">pruneMatchingLeaves:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Traverses an array-based tree structure, removing any leaves whose values
match a given test expression. The resulting pruned tree is then returned.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)pruneMatchingLeaves:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>input array</em> representing the root of the tree; this expression
must evaluate to an <code>NSArray</code> instance</p></li>
<li><p>The <em>test expression</em>, which will be evaluated once for each
non-array element found while traversing the tree</p></li>
</ul>


<p>The function will return an tree structure similar to the input
structure, but containing only those non-array elements for which the
<em>test expression</em> evaluates to <code>NO</code>.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$input</code> is an array containing two inner arrays. The first inner
array contains the strings: &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and &ldquo;<code>Pat</code>&rdquo;; the second inner
array contains: &ldquo;<code>Alice</code>&rdquo;, &ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^pruneMatchingLeaves($input|$item -EQ Pat)
</code></pre>

<p>The expression above would return an array containing two inner arrays,
the first having the elements &ldquo;<code>Bob</code>&rdquo; and &ldquo;<code>Joe</code>&rdquo;, and the second having
the elements &ldquo;<code>Alice</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/pruneNonmatchingLeaves:" title="pruneNonmatchingLeaves:"></a>
	<h3 class="subsubtitle method-title">pruneNonmatchingLeaves:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Traverses an array-based tree structure, removing any leaves whose values
do not match a given test expression. The resulting pruned tree is then
returned.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)pruneNonmatchingLeaves:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>input array</em> representing the root of the tree; this expression
must evaluate to an <code>NSArray</code> instance</p></li>
<li><p>The <em>test expression</em>, which will be evaluated once for each
non-array element found while traversing the tree</p></li>
</ul>


<p>The function will return an tree structure similar to the input
structure, but containing only those non-array elements for which the
<em>test expression</em> evaluates to <code>YES</code>.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$input</code> is an array containing two inner arrays. The first inner
array contains the strings: &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and &ldquo;<code>Pat</code>&rdquo;; the second inner
array contains: &ldquo;<code>Alice</code>&rdquo;, &ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^pruneNonmatchingLeaves($input|$item -EQ Pat)
</code></pre>

<p>The expression above would return an array containing two inner arrays,
each with a single element: &ldquo;<code>Pat</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/reduce:" title="reduce:"></a>
	<h3 class="subsubtitle method-title">reduce:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reduce an array of items into a single item.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)reduce:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The result of the reduction.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts 3 pipe-separated expressions as parameters:</p>

<ul>
<li><p>The <em>source array</em>, an object expression expected to yield an <code>NSArray</code>
 instance</p></li>
<li><p>The <em>initial value</em>, an object expression yielding the initial value for
 the reduce operation</p></li>
<li><p>The <em>combining expression</em>, an object expression yielding the result of
 combining the <em>current value</em> with the current item in the array.</p></li>
</ul>


<p>The return value is an array whose items are constructed by iterating over the
source array and for each item in the array, evaluating the combining
expression.</p>

<p>The combining expression may refer to the <em>current reduced value</em> using
<code>$currentValue</code>. The current reduced value is the result of the previous
evaluation of the combining expression. For the first item in the source
array, the combining expression has not yet been evaluated, so the
initial value is used as <code>$currentValue</code>.</p>

<h4>Expression usage</h4>

<pre><code>^reduce(^arrayFilledWithIntegers(1|10)|0|#($currentValue + $item))
</code></pre>

<p>The expression above would return the result <code>55</code>.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setContains:" title="setContains:"></a>
	<h3 class="subsubtitle method-title">setContains:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Determines whether a set contains a given object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)setContains:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An <code>NSNumber</code> containing a boolean value indicating the result
            of the function.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Because this function is optimized to work with <code>NSSet</code> instances, it is
more efficient than using <code>^containsValue()</code> for the same purpose.</p>

<p>This function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>A <em>set</em> expression, which should yield an <code>NSSet</code> instance, and</p></li>
<li><p>An <em>object</em> expression, which yields the object whose presence in the
set is to be tested.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that the MBML variable <code>$colors</code> is a set containing the values &ldquo;<code>red</code>&rdquo;,
&ldquo;<code>yellow</code>&rdquo;, &ldquo;<code>green</code>&rdquo;, and &ldquo;<code>blue</code>&rdquo;:</p>

<pre><code>^setContains($colors|orange)
</code></pre>

<p>The expression above would return a boolean <code>NO</code>, because <code>$colors</code> does
not contain the value &ldquo;<code>orange</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sort:" title="sort:"></a>
	<h3 class="subsubtitle method-title">sort:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns an array containing the sorted values of a container object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)sort:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The function result.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts between one and three expressions as
input parameters:</p>

<ul>
<li><p>The <em>data model</em>, the container object whose sorted values are to be
 returned</p></li>
<li><p>An optional <em>sort key</em>, an expression indicating the value within <em>data
 model</em> that should be used for the basis of sorting. If omitted, the
 default value is <code>$item</code>, meaning that the value itself should be
 used for sorting. Subvalues of <code>$item</code> may also be specified. This
 parameter must be provided when the <em>descending order specifier</em>
 parameter is used.</p></li>
<li><p>An optional <em>descending order specifier</em>. If this string expression yields
 the value &ldquo;<code>desc</code>&rdquo;, sorting will occur in descending order. If this
 parameter is omitted or if the value is anything else, sorting will occur
 in the default ascending order.</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume <code>$buildings</code> represents a collection object whose members have a
<code>height</code> property indicating the corresponding building&rsquo;s height in feet:</p>

<pre><code>^sort($buildings|$item.height|desc)
</code></pre>

<p>The expression above would return an array containing each item in <code>$building</code>
sorted from tallest to shortest.</p>

<pre><code>^sort(^array(z|x|a|c|y|b))
</code></pre>

<p>The expression above yields the array: [&ldquo;<code>a</code>&rdquo;, &ldquo;<code>b</code>&rdquo;, &ldquo;<code>c</code>&rdquo;, &ldquo;<code>x</code>&rdquo;, &ldquo;<code>y</code>&rdquo;,
&ldquo;<code>z</code>&rdquo;].</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/split:" title="split:"></a>
	<h3 class="subsubtitle method-title">split:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Creates an array by splitting a string on a given delimeter.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)split:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An array containing the components of the split string.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated expressions as parameters:</p>

<ul>
<li><p>An expression specifying the <em>delimiter</em>, which specifies where
the <em>input string</em> will be split</p></li>
<li><p>An expression specifying the <em>input string</em>, which is the
string to be split</p></li>
</ul>


<h4>Expression usage:</h4>

<pre><code>^split(, |Evan, Jesse, Yon)
</code></pre>

<p>The expression above would return an array containing three elements:
&ldquo;<code>Evan</code>&rdquo;, &ldquo;<code>Jesse</code>&rdquo;, and &ldquo;<code>Yon</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/splitLines:" title="splitLines:"></a>
	<h3 class="subsubtitle method-title">splitLines:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Creates an array by splitting a string at newlines.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)splitLines:(NSString *)<em>stringToSplit</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>stringToSplit</em></dt>
			<dd><p>The string being split.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An <code>NSArray</code> containing the individual lines of <code>stringToSplit</code>.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This function accepts a single Mockingbird expression, the <em>input string</em>
that will be split on newlines.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$lines</code> is a string containing newlines:</p>

<pre><code>^splitLines($lines)
</code></pre>

<p>The expression above would return an array containing one element for each
line in <code>$lines</code>, where each element contains a single line of text (with
newlines stripped off).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/unique:" title="unique:"></a>
	<h3 class="subsubtitle method-title">unique:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Iterates over the values supplied by the passed-in enumerator, and returns an
array containing the unique values encountered.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)unique:(NSObject&lt;NSFastEnumeration&gt; *)<em>enumerator</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>enumerator</em></dt>
			<dd><p>The function&rsquo;s input parameter.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>a set containing the unique values in the input parameter.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This function accepts a single Mockingbird expression, which it expects to
evaluate to an object that implements the <code>NSFastEnumeration</code>
protocol (such as an <code>NSArray</code> or <code>NSSet</code>). The values
in the returned array will be in the same order that they were supplied by
the enumerator.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$animals</code> is an array with three elements: the strings &ldquo;<code>Duck</code>&rdquo;,
&ldquo;<code>Duck</code>&rdquo; and &ldquo;<code>Goose</code>&rdquo;.</p>

<pre><code>^unique($animals)
</code></pre>

<p>The expression above would return an array containing two strings: &ldquo;<code>Duck</code>&rdquo;
and &ldquo;<code>Goose</code>&rdquo;, in that order.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/valuesIntersect:" title="valuesIntersect:"></a>
	<h3 class="subsubtitle method-title">valuesIntersect:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Tests whether two container objects share at least one value in common.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)valuesIntersect:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p><code>@YES</code> if the two container objects share at least one common value,
            <code>@NO</code> if they do not.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two pipe-separated object expressions
yielding the container objects to test.</p>

<p>The function returns <code>@YES</code> if the two container objects share at least
one common value, <code>@NO</code> if they do not.</p>

<h4>Expression usage</h4>

<p>Assume that <code>$boys</code> is an <code>NSSet</code> containing the strings &ldquo;<code>Bob</code>&rdquo;, &ldquo;<code>Joe</code>&rdquo; and
&ldquo;<code>Pat</code>&rdquo;, and that <code>$girls</code> is an <code>NSSet</code> containing the strings &ldquo;<code>Alice</code>&rdquo;,
&ldquo;<code>Pat</code>&rdquo; and &ldquo;<code>Sally</code>&rdquo;.</p>

<pre><code>^valuesIntersect($boys|$girls)
</code></pre>

<p>The expression above would return <code>@YES</code> because both <code>$boys</code> and <code>$girls</code>
share a common value: the string &ldquo;<code>Pat</code>&rdquo;.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/valuesPassingTest:" title="valuesPassingTest:"></a>
	<h3 class="subsubtitle method-title">valuesPassingTest:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Tests a boolean expression against the values in one or more container objects,
and returns an array of values for which the test expression is true.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (id)valuesPassingTest:(NSArray *)<em>params</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>params</em></dt>
			<dd><p>The function&rsquo;s input parameters.</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>An array containing the values in the container objects
            for which the test expression evaluates to true</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This Mockingbird function accepts two or more pipe-separated expressions
yielding:</p>

<ul>
<li><p>One or more <em>container objects</em></p></li>
<li><p>The <em>test expression</em>, an expression that will be evaluated for each
value in each container object in the input parameters</p></li>
</ul>


<p>The test expression can refer to the following pre-defined variables:</p>

<ul>
<li><p><code>$item</code> refers to the value in a container object that&rsquo;s
currently being tested</p></li>
<li><p>When the container object being tested is a dictionary, <code>$key</code>
can be used to access the key associated with the current <code>$item</code></p></li>
<li><p><code>$root</code> contains the value of the current item being iterated
at the top level of the data model</p></li>
</ul>


<h4>Expression usage</h4>

<p>Assume that <code>$articles</code> and <code>$videos</code>
are containers whose values each have a <code>displayOrder</code> attribute:</p>

<pre><code>^valuesPassingTest($articles|$videos|$item.displayOrder -EQ 1)
</code></pre>

<p>The expression above would iterate over all the values in the
<code>$articles</code> and then the <code>$videos</code> container objects, and
for each value, it would perform a <code>$item.displayOrder -EQ 1</code> boolean
test. Each value in <code>$articles</code> and <code>$videos</code> for which
the expression <code>$item.displayOrder -EQ 1</code> evaluates to true will be
placed into the array returned by the function.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">MBMLDataProcessingFunctions.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
					
					
                    
                    
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2015 Gilt Groupe. All rights reserved. (Last updated: 2015-01-23)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2 (build 963)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>